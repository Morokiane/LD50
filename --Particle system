--Particle system
particle_systems={}

-- Call this, to create an empty particle system, and then fill the emittimers, emitters,
-- drawfuncs, and affectors tables with your parameters.
function make_psystem(minlife, maxlife, minstartsize, maxstartsize, minendsize, maxendsize)
	local ps={
	-- global particle system params

	-- if true, automatically deletes the particle system if all of it's particles died
	autoremove=true,

	minlife=minlife,
	maxlife=maxlife,

	minstartsize=minstartsize,
	maxstartsize=maxstartsize,
	minendsize=minendsize,
	maxendsize=maxendsize,

	-- container for the particles
	particles={},

	-- emittimers dictate when a particle should start
	-- they called every frame, and call emit_particle when they see fit
	-- they should return false if no longer need to be updated
	emittimers={},

	-- emitters must initialize prt.x, prt.y, p.vx, p.vy
	emitters={},

	-- every ps needs a drawfunc
	drawfuncs={},

	-- affectors affect the movement of the particles
	affectors={},
	}

	table.insert(particle_systems,ps)

	return ps
end

-- Call this to update all particle systems
function update_psystems()
	local timenow=time()
	for key,ps in pairs(particle_systems) do
		update_ps(ps,timenow)
	end
end

-- updates individual particle systems
-- most of the time, you don't have to deal with this, the above function is sufficient
-- but you can call this if you want (for example fast forwarding a particle system before first draw)
function update_ps(ps,timenow)
	for key,et in pairs(ps.emittimers) do
		local keep=et.timerfunc(ps, et.params)
		if not keep then
			table.remove(ps.emittimers, key)
		end
	end

	for key,p in pairs(ps.particles) do
		p.phase=(timenow-p.starttime)/(p.deathtime-p.starttime)

		for key,a in pairs(ps.affectors) do
			a.affectfunc(p,a.params)
		end

		prt.x=prt.x+p.vx
		prt.y=prt.y+p.vy

		local dead=false
		if (prt.x<0 or prt.x>240 or prt.y<0 or prt.y>136) then
			dead=true
		end

		if timenow>=p.deathtime then
			dead=true
		end

		if dead then
			table.remove(ps.particles,key)
		end
	end

	if (ps.autoremove and #ps.particles<=0) then
		local psidx=-1
		for pskey,pps in pairs(particle_systems) do
			if pps==ps then
				table.remove(particle_systems,pskey)
				return
			end
		end
	end
end
-- draw a single particle system
function draw_ps(ps,params)
	for key,df in pairs(ps.drawfuncs) do
		df.drawfunc(ps,df.params)
	end
end
-- draws all particle system
-- This is just a convinience function, you probably want to draw the individual particles,
-- if you want to control the draw order in relation to the other game objects for example
function draw_psystems()
	for key,ps in pairs(particle_systems) do
		draw_ps(ps)
	end
end
-- This need to be called from emitttimers, when they decide it is time to emit a particle
function emit_particle(psystem)
	local p={}

	local ecount=nil
	local e=psystem.emitters[math.random(#psystem.emitters)]
	e.emitfunc(p,e.params)

	p.phase=0
	p.starttime=time()
	p.deathtime=time()+frnd(psystem.maxlife-psystem.minlife)+psystem.minlife

	p.startsize=frnd(psystem.maxstartsize-psystem.minstartsize)+psystem.minstartsize
	p.endsize=frnd(psystem.maxendsize-psystem.minendsize)+psystem.minendsize

	table.insert(psystem.particles,p)
end

function frnd(max)
	return math.random()*max
end

function make_smoke_ps(ex,ey)
	local ps=make_psystem(200,2000,1,3,6,9)
	
	ps.autoremove=false

	table.insert(ps.emittimers,
		{
			timerfunc=emittimer_constant,
			params={nextemittime=time(),speed=100}
		}
	)
	table.insert(ps.emitters, 
		{
			emitfunc=emitter_box,
			params={minx=ex-4,maxx=ex+14,miny=ey,maxy=ey+2,minstartvx=0,maxstartvx=0,minstartvy=0,maxstartvy=0}
		}
	)
	table.insert(ps.drawfuncs,
		{
			drawfunc=draw_ps_fillcirc,
			params={colors={2,3,4}}
		}
	)
	table.insert(ps.affectors,
		{ 
			affectfunc=affect_force,
			params={fx=0.003,fy=-0.009 }
			--affectfunc=affect_forcezone,
			--params={fx=0.003,fy=-0.009,zoneminx=0--[[64]],zonemaxx=127,zoneminy=64,zonemaxy=100}
		}
	)
end

--================================================================--
-- MODULES =======================================================--
--================================================================--

-- You only need to copy the modules you actually use to your program


-- EMIT TIMERS ==================================================--

-- Emits a particle every "speed" time
-- params:
-- speed - time between particle emits
function emittimer_constant(ps,params)
	if (params.nextemittime<=time()) then
		emit_particle(ps)
		params.nextemittime=params.nextemittime+params.speed
	end
	return true
end

-- EMITTERS =====================================================--

-- Emits particles from the surface of a rectangle
-- params:
-- minx,miny and maxx, maxy - the corners of the rectangle
-- minstartvx, minstartvy and maxstartvx, maxstartvy - the start velocity is randomly chosen between these values
function emitter_box(p,params)
	prt.x=frnd(params.maxx-params.minx)+params.minx
	prt.y=frnd(params.maxy-params.miny)+params.miny

	p.vx=frnd(params.maxstartvx-params.minstartvx)+params.minstartvx
	p.vy=frnd(params.maxstartvy-params.minstartvy)+params.minstartvy
end

-- AFFECTORS ====================================================--

-- Constant force applied to the particle troughout it's life
-- Think gravity, or wind
-- params: 
-- fx and fy - the force vector
function affect_force(p,params)
	p.vx=p.vx+params.fx
	p.vy=p.vy+params.fy
end

-- A rectangular region, if a particle happens to be in it, apply a constant force to it
-- params: 
-- zoneminx, zoneminy and zonemaxx, zonemaxy - the corners of the rectangular area
-- fx and fy - the force vector
function affect_forcezone(p,params)
	if (prt.x>=params.zoneminx and prt.x<=params.zonemaxx and prt.y>=params.zoneminy and prt.y<=params.zonemaxy) then
		p.vx=p.vx+params.fx
		p.vy=p.vy+params.fy
	end
end

-- DRAW FUNCS ===================================================--

-- Filled circle particle drawer, the particle animates it's size and color trough it's life
-- params:
-- colors array - indexes to the palette, the particle goes trough these in order trough it's lifetime
-- startsize and endsize is coming from the particle system parameters, not the draw func params!
function draw_ps_fillcirc(ps,params)
	for key,p in pairs(ps.particles) do
		cs=math.floor(p.phase*#params.colors)+1
		r=(1-p.phase)*p.startsize+p.phase*p.endsize
		circ(prt.x-cam.x,prt.y-cam.y,r,params.colors[cs])
	end
end